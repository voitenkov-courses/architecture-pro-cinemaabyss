// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"time"

	"github.com/gin-gonic/gin"
)

// Error defines model for Error.
type Error struct {
	// Error Сообщение об ошибке
	Error string `json:"error"`
}

// Event defines model for Event.
type Event struct {
	// Id Уникальный идентификатор события
	Id string `json:"id"`

	// Payload Полезная нагрузка события (зависит от типа события)
	Payload map[string]interface{} `json:"payload"`

	// Timestamp Время события
	Timestamp time.Time `json:"timestamp"`

	// Type Тип события
	Type string `json:"type"`
}

// EventResponse defines model for EventResponse.
type EventResponse struct {
	Event Event `json:"event"`

	// Offset Смещение в партиции Kafka
	Offset int `json:"offset"`

	// Partition Партиция Kafka
	Partition int `json:"partition"`

	// Status Статус операции
	Status string `json:"status"`
}

// MovieEvent defines model for MovieEvent.
type MovieEvent struct {
	// Action Действие с фильмом
	Action string `json:"action"`

	// Description Описание фильма (опционально)
	Description *string `json:"description,omitempty"`

	// Genres Жанры фильма (опционально)
	Genres *[]string `json:"genres,omitempty"`

	// MovieId Идентификатор фильма
	MovieId int `json:"movie_id"`

	// Rating Рейтинг (опционально)
	Rating *float32 `json:"rating,omitempty"`

	// Title Название фильма
	Title string `json:"title"`

	// UserId Идентификатор пользователя (опционально)
	UserId *int `json:"user_id,omitempty"`
}

// PaymentEvent defines model for PaymentEvent.
type PaymentEvent struct {
	// Amount Сумма платежа
	Amount float32 `json:"amount"`

	// MethodType Тип метода оплаты (опционально)
	MethodType *string `json:"method_type,omitempty"`

	// PaymentId Идентификатор платежа
	PaymentId int `json:"payment_id"`

	// Status Статус платежа
	Status string `json:"status"`

	// Timestamp Время платежа
	Timestamp time.Time `json:"timestamp"`

	// UserId Идентификатор пользователя
	UserId int `json:"user_id"`
}

// UserEvent defines model for UserEvent.
type UserEvent struct {
	// Action Действие пользователя
	Action string `json:"action"`

	// Email Email пользователя (опционально)
	Email *string `json:"email,omitempty"`

	// Timestamp Время события
	Timestamp time.Time `json:"timestamp"`

	// UserId Идентификатор пользователя
	UserId int `json:"user_id"`

	// Username Имя пользователя (опционально)
	Username *string `json:"username,omitempty"`
}

// CreateMovieEventJSONRequestBody defines body for CreateMovieEvent for application/json ContentType.
type CreateMovieEventJSONRequestBody = MovieEvent

// CreatePaymentEventJSONRequestBody defines body for CreatePaymentEvent for application/json ContentType.
type CreatePaymentEventJSONRequestBody = PaymentEvent

// CreateUserEventJSONRequestBody defines body for CreateUserEvent for application/json ContentType.
type CreateUserEventJSONRequestBody = UserEvent

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Проверка работоспособности микросервиса событий
	// (GET /api/events/health)
	GetEventsServiceHealth(c *gin.Context)
	// Создание события фильма
	// (POST /api/events/movie)
	CreateMovieEvent(c *gin.Context)
	// Создание события платежа
	// (POST /api/events/payment)
	CreatePaymentEvent(c *gin.Context)
	// Создание события пользователя
	// (POST /api/events/user)
	CreateUserEvent(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetEventsServiceHealth operation middleware
func (siw *ServerInterfaceWrapper) GetEventsServiceHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetEventsServiceHealth(c)
}

// CreateMovieEvent operation middleware
func (siw *ServerInterfaceWrapper) CreateMovieEvent(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateMovieEvent(c)
}

// CreatePaymentEvent operation middleware
func (siw *ServerInterfaceWrapper) CreatePaymentEvent(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreatePaymentEvent(c)
}

// CreateUserEvent operation middleware
func (siw *ServerInterfaceWrapper) CreateUserEvent(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateUserEvent(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/api/events/health", wrapper.GetEventsServiceHealth)
	router.POST(options.BaseURL+"/api/events/movie", wrapper.CreateMovieEvent)
	router.POST(options.BaseURL+"/api/events/payment", wrapper.CreatePaymentEvent)
	router.POST(options.BaseURL+"/api/events/user", wrapper.CreateUserEvent)
}
